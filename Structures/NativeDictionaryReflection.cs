using System.Drawing;

namespace Structures;

public abstract class NativeDictionaryReflection
{
    // В моей реализации я слишком рано залез в детали, которые вообще не должны быть на уровне
    // абстракции. Самая большая ошибка — это то, что я добавил capacity и заставляю передавать
    // его прямо в конструктор абстрактного класса. По сути, я навязываю конкретной реализации, как
    // она должна хранить данные — с фиксированным размером, как будто других вариантов нет. А абстрактный
    // уровень как раз и нужен для того, чтобы описывать что словарь умеет, а не как он это делает. Такие 
    // вещи, как размер массива, коллизии и всё, что связано с внутренним устройством — это уже забота 
    // конкретной реализации, а не общей схемы. Да, capacity — это не что-то плохое само по себе.
    // Например, если мы делаем абстракцию массива, то передавать размер — это нормально. Но в случае 
    // словаря, особенно если он может быть реализован динамически, это ограничивает свободу и делает 
    // абстракцию жёсткой и негибкой. В остальном всё получилось довольно хорошо. Команды и запросы
    // разделены, статусы операций понятные. Метод Clear, хоть его и нет в эталоне, считаю полезным и 
    // убирать его не вижу смысла.
}

