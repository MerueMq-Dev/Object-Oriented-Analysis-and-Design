using System.Drawing;

namespace Structures;

public abstract class NativeDictionaryReflection
{
    // В моей реализации я по ошибке вынес слишком много конкретики в АТД. Я добавил в
    // него capacity — размер внутреннего массива — и описал предусловия, связанные с тем, есть ли
    // свободное место для нового элемента. В результате абстрактный класс уже знает, как устроен словарь
    // внутри, а это неправильно именно для данной структуры. Абстракция должна описывать только что умеет
    // делать словарь — добавлять, удалять, искать по ключу — но не как именно это реализовано. Все детали,
    // вроде размера, коллизий и внутреннего хранения, должны оставаться внутри конкретной реализации.
    // Хочу добавить, что сам по себе параметр capacity на уровне абстракции — не всегда ошибка. Например,
    // для абстрактного типа данных массива или стека с ограниченной размерностью это может быть вполне 
    // допустимо. Но конкретно в случае словаря, где реализация может быть динамической и не обязана зависеть
    // от фиксированного размера, включение capacity в абстракцию делает её слишком жёстко привязанной 
    // к определённой внутренней логике, что ограничивает гибкость и переиспользуемость.
    // В остальном структура класса получилась логичной: команды и запросы разделены, статусы операций 
    // выделены явно, что делает логику понятной. Метод Clear считаю полезным — он может пригодиться, даже
    // если его нет в эталонном решении
}

