namespace Structures;

public abstract class LinkedListReflection<T>
{

    // Правильные решения в моем АТД 
    // Корректная структура: Правильно выделил основные группы операций - команды и запросы, что
    // соответствует принципам АТД.
    // Система статусов: Хоть и упрощенная, но логично организованная - отдельные статусы для курсора
    // и поиска покрывают основные сценарии ошибок.
    // Предусловия и постусловия: В большинстве случаев правильно определил контракты методов.
    
    // Основные различия
    // Первое: У меня вся проверка статусов завязана на статусе курсора (CursorNil/Ok/Err/Empty и
    // FindNil/Ok/Err). В эталонном решении же для каждой операции есть свой отдельный статус через
    // методы get_*_status().
    // Второе: По какой-то причине у меня потерялся метод Clear() который очищает связный список.
    // Третье: В эталонном решении в постусловии для метода Remove() более подробно описано поведение 
    // курсора при удалении - "курсор смещён к правому соседу, если он есть, в противном случае курсор
    // смещён к левому соседу". У меня просто "курсор сместился к соседнему элементу".
    // Четвёртое: В моём решении у метода Find() есть лишнее предусловие "предусловие: искомый элемент
    // должен быть в связном списке", что делает метод бесполезным - если мы заранее знаем, что элемент
    // есть, зачем его искать?
    
    // Дополнительные вопросы
    // Вопрос 2.2 (Операция tail): Мой ответ правильный - корректно объяснил разницу в временной сложности O(1)
    // vs O(n). Эталонный ответ дает тот же вывод, но добавляет важную деталь про необходимость хранения tail_pointer 
    // в реализации и подчеркивает принцип проектирования АТД с учетом эффективности.
    // Мой ответ правильный и более детальный - показал конкретный механизм использования Find() 
    // в цикле с проверкой статуса. Эталонный ответ дает тот же смысл, но более кратко.
}
