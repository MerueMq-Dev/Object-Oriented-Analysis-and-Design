namespace Structures;

public class PowerSetReflection
{
       // В моём решении есть несколько отличий от эталонного. Сначала я переопределил метод Put, добавив уточнение,
       // что элемент добавляется только если его ещё нет в множестве. Мне казалось, это важно для точности, но на 
       // самом деле базовый класс уже учитывает такое поведение, так что переопределение оказалось лишним. То же
       // самое с методом GetPutStatus — он просто дублирует то, что уже есть, и только усложняет код.
       // Я также добавил методы IsEmpty и Equals. IsEmpty — для проверки на пустоту, Equals — для сравнения двух
       // множеств.
       // Самое спорное решение — добавление интерфейса IEnumerable<T> в абстрактный тип. Это позволило перебирать
       // элементы через foreach, и благодаря этому я смог реализовать методы Intersection, Difference, Union и 
       // IsSubset. На тот момент мне казалось, что по-другому доступ к элементам реализовать нельзя.
       // Но после того как я посмотрел эталонное решение и переосмыслил свой подход, понял, что это не лучшая идея.
       // IEnumerable<T> — это специфичная часть C#, а абстрактный тип данных должен быть максимально независим от
       // конкретного языка. Кроме того, навязывая этот интерфейс, я заставляю все наследники реализовывать перебор,
       // даже если он им не нужен. Более гибким вариантом было бы просто ввести метод вроде GetElements(), который 
       // возвращает все элементы в виде списка или массива. А ещё проще — просто оставить этот выбор на усмотрение тех, 
       // кто будет реализовывать конкретные версии АТД.
}