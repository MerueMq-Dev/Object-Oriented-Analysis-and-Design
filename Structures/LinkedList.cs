namespace Structures;

public abstract class OriginalLinkedList<T>
{
    public const int CursorNil = 0; // курсор ещё не инициализирован 
    public const int CursorOk = 1; // последняя операция с курсором отработала нормально
    public const int CursorErr = 2; // последняя операция с курсором отработала с ошибкой
    public const int CursorEmpty = 3; // последняя операция привела к пустому списку и пустому курсору
    
    public const int FindNil = 0;   // Find ещё не вызывался
    public const int FindOk = 1;   // узел найден и курсор перемещен
    public const int FindErr = 2;  // узел не найден, курсор не изменился
    
    
    // конструктор
    public OriginalLinkedList(){} // постусловие: создан новый пустой связный список
    
    // команды:
    // предусловие: связный список не пустой;
    // постусловие: курсор переставлен на голову связного списка 
    public abstract void Head();
    
    // предусловие: связный список не пустой;
    // постусловие: курсор переставлен на хвост связного списка
    public abstract void Tail();
    
    // предусловие: связный список не пустой;
    // предусловие: курсор находится не на последнем элементе;
    // постусловие: курсор переставлен на один узел вправо связного списка
    public abstract void Right();

    // предусловие: связный список не пустой;
    // постусловие: новый узел с заданным значением вставлен следом за текущим узлом
    public abstract void PutRight(T value);
    
    // предусловие: связный список не пустой;
    // постусловие: новый узел с заданным значением вставлен перед текущим узлом
    public abstract void PutLeft(T value);
    
    // предусловие: связный список не пустой;
    // постусловие: узел удалён, курсор сместился к соседнему элементу
    public abstract void Remove();

    // предусловие: связный список пустой;
    // постусловие: новый узел с заданным значением добавлен в пустой список
    // и на этот узел установлен курсор. 
    public abstract void AddToEmpty(T value);
    
    // постусловие: новый узел вставлен в хвост связного списка;
    public abstract void AddTail(T value);
    
    // предусловие: связный список не пустой;
    // постусловие: значение в узле, на который указывал курсор, было изменено на заданное,
    public abstract void Replace(T value);
    
    // предусловие: связный список не пустой;
    // предусловие: искомый элемент должен быть в связном списке;
    // постусловие: если следующий узел с искомым значением найден (по отношению к текущему узлу)
    // то курсор установлен на него иначе курсор не изменился
    public abstract void Find(T value);
    
    // постусловие: все узлы с заданным значением удалены
    public abstract void RemoveAll(T value);
    
    
    // запросы:
    // предусловие: связный список не пустой;
    public abstract T Get(); 
    
    public abstract int Size();
    
    // предусловие: связный список не пустой;
    public abstract bool IsHead();
    
    // предусловие: связный список не пустой;
    public abstract bool IsTail();
    
    public abstract bool IsValue();
    
    // дополнительные запросы:
    public abstract int GetCursorStatus(); // возвращает значение Cursor*
    public abstract int GetFindStatus(); // возвращает значение Cursor*
}

//2.2
// Операция Tail() не сводима к другим операциям, потому что её прямая реализация 
// имеет временную сложность O(1), в то время как любая реализация через доступные
// операции (Head() и последовательные Right()) будет иметь сложность O(n). Поскольку
// нельзя получить константное время из операций, дающих в сумме линейное время, поэтому
// Tail() является примитивной операцией, которая требует прямого доступа к внутренней 
// структуре данных для эффективной реализаци.


//2.3
// Операция поиска всех узлов с заданным значением не нужна, потому что у нас есть
// метод Find(), который можно вызывать в цикле до тех пор, пока GetFindStatus() не
// вернет статус ошибки, что означает отсутствие дальнейших совпадений.

